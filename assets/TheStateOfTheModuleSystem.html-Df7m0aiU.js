import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as i,o as n}from"./app-DmBK_9ta.js";const l="/assets/images/posts/java-core/tsotms01.png",t="/assets/images/posts/java-core/tsotms02.png",r="/assets/images/posts/java-core/tsotms03.png",p="/assets/images/posts/java-core/tsotms04.png",o="/assets/images/posts/java-core/tsotms05.png",h={};function d(c,s){return n(),e("div",null,s[0]||(s[0]=[i(`<h1 id="the-state-of-the-module-system" tabindex="-1"><a class="header-anchor" href="#the-state-of-the-module-system"><span>The State of the Module System</span></a></h1><p>前文概述：此篇文章的内容来源于OpenJDK的一篇文档，这是我非常推荐的一种学习方式。阅读官方文档，因为在这些文档里的某些句子里面，暗藏着一些设计思路，理解思路很重要。<br> 原文地址：<br><a href="https://openjdk.org/projects/jigsaw/spec/sotms/" target="_blank" rel="noopener noreferrer">The State of the Module System</a></p><h2 id="goals-of-the-module-system" tabindex="-1"><a class="header-anchor" href="#goals-of-the-module-system"><span>Goals of the module system</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Reliable configuration, to replace the brittle, error-prone class-path mechanism with a means for program components to declare explicit dependences upon one another, along with</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Strong encapsulation, to allow a component to declare which of its public types are accessible to other components, and which are not.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>模块系统的具体目标是提供可靠的配置，以一种方式替换脆弱且容易出错的类路径机制，使程序组件能够显式声明彼此之间的依赖关系，以及提供强大的封装功能，使组件可以声明其公共类型中哪些是对其他组件可访问的，而哪些则不可访问。</p><h2 id="defining-modules" tabindex="-1"><a class="header-anchor" href="#defining-modules"><span>Defining Modules</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>A module is a named, self-describing collection of code and data. Its code is organized as a set of packages containing types.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>模块是一个具有名称的、自我描述的代码和数据集合。其代码组织为包含类型的一组包。</p><h3 id="module-decalrations" tabindex="-1"><a class="header-anchor" href="#module-decalrations"><span>Module Decalrations</span></a></h3><p>模块的自描述通过它的模块声明来表达，这是Java编程语言的一种新结构。最简单的模块声明仅仅指定模块的名称</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> com</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.foo.bar { </span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以添加一个或多个requires子句，以声明该模块在编译时和运行时都依赖于某些其他模块（通过名称）。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> com</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.foo.bar {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> org.baz.qux;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以添加导出条款声明模块仅将特定包中的所有公共类型提供给其他模块使用</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> com</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.foo.bar {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> org.baz.qux;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> com.foo.bar.alpha;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> com.foo.bar.beta;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>按照惯例，一个模块声明的源代码通常放置在模块源文件层次结构根目录中的名为module-info.java的文件中。</p><p>模块名称与包名称一样，必须不发生冲突。推荐的命名模块方式是使用长期以来推荐用于命名包的反向域名模式。因此，模块的名称通常是其导出包名称的前缀，但这种关系并不是强制性的。</p><p>模块的声明不包含版本字符串，也不包括对其依赖模块的版本字符串的限制。这是有意为之，因为模块系统的目标不是解决版本选择问题，该问题更适合交由构建工具和容器应用处理。</p><h3 id="module-artifacts" tabindex="-1"><a class="header-anchor" href="#module-artifacts"><span>Module Artifacts</span></a></h3><p>一个模块化的 JAR 文件在所有可能的方面都与普通的 JAR 文件相似，只是它在其根目录中还包含一个 module-info.class 文件。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>META-INF/</span></span>
<span class="line"><span>META-INF/MANIFEST.MF</span></span>
<span class="line"><span>module-info.class</span></span>
<span class="line"><span>com/foo/bar/alpha/AlphaFactory.class</span></span>
<span class="line"><span>com/foo/bar/alpha/Alpha.class</span></span>
<span class="line"><span>...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="platform-modules" tabindex="-1"><a class="header-anchor" href="#platform-modules"><span>Platform Modules</span></a></h3><p>Java SE 9 平台规范将使用模块系统将平台划分为一组模块。Java SE 9 平台的一个实现可能包含所有平台模块，或者仅包含其中的一部分。模块系统唯一明确知道的模块是基础模块，命名为 java.base 。基础模块定义并导出所有平台的核心包，包括模块系统本身：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>module java.base {</span></span>
<span class="line"><span>  exports java.io;</span></span>
<span class="line"><span>  exports java.lang;</span></span>
<span class="line"><span>  exports java.lang.annotation;</span></span>
<span class="line"><span>  exports java.lang.invoke;</span></span>
<span class="line"><span>  exports java.lang.module;</span></span>
<span class="line"><span>  exports java.lang.ref;</span></span>
<span class="line"><span>  exports java.lang.reflect;</span></span>
<span class="line"><span>  exports java.math;</span></span>
<span class="line"><span>  exports java.net;</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>基础模块总是存在的。每个其他模块都隐式依赖于基础模块，而基础模块不依赖于其他模块。<br> 其余的平台模块将共享“java.”名称前缀，并可能包括，例如，java.sql 用于数据库连接，java.xml 用于 XML 处理，以及 java.logging 用于日志记录。在 Java SE 9 平台规范中未定义但特定于 JDK 的模块将按惯例共享“jdk.”名称前缀。</p><h2 id="using-modules" tabindex="-1"><a class="header-anchor" href="#using-modules"><span>Using Modules</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>To make use of them in either phase the module system must locate them and, then, determine how they relate to each other so as to provide reliable configuration and strong encapsulation.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>为了在任一阶段中使用模块，模块系统必须先定位它们，然后确定它们之间的关系，从而提供可靠的配置和强大的封装。</p><h3 id="the-module-path" tabindex="-1"><a class="header-anchor" href="#the-module-path"><span>The Module Path</span></a></h3><p>为了定位定义在工件中的模块，模块系统会搜索模块路径，该路径由主机系统定义。模块路径是一个序列，其中每个元素要么是一个模块工件，要么是一个包含模块工件的目录。模块路径的元素按顺序被搜索，寻找第一个定义适用模块的工件。</p><p>编译时或运行时环境内置的模块，以及模块路径上定义的模块，共同称为可观察模块的集合。</p><h3 id="resolution" tabindex="-1"><a class="header-anchor" href="#resolution"><span>Resolution</span></a></h3><p>假设我们有一个使用上述 com.foo.bar 模块以及平台的 java.sql 模块的应用程序。包含应用程序核心的模块声明如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>module com.foo.app {</span></span>
<span class="line"><span>  requires com.foo.bar;</span></span>
<span class="line"><span>  requires java.sql;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>给定这个初始应用模块，模块系统通过定位额外的可观测模块(observable modules)来解决其 requires 子句中表达的依赖关系，以满足这些依赖关系，然后进一步解决这些模块的依赖关系，如此循环往复，直到每个模块的每个依赖关系都得到满足。这个传递闭包计算的结果是一个模块图，对于每个依赖关系由其他模块满足的模块来说，该图包含从第一个模块到第二个模块的一个有向边。</p><p>要为 com.foo.app 模块构建模块图，模块系统会检查 java.sql 模块的声明，其内容如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>module java.sql {</span></span>
<span class="line"><span>  requires java.logging;</span></span>
<span class="line"><span>  requires java.xml;</span></span>
<span class="line"><span>  exports java.sql;</span></span>
<span class="line"><span>  exports javax.sql;</span></span>
<span class="line"><span>  exports javax.transaction.xa;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它还检查了 com.foo.bar 模块的声明（上面已经展示过），以及 org.baz.qux、java.logging 和 java.xml 模块的声明；为了简洁，这后三者没有在这里展示，因为它们没有声明对其他模块的依赖。</p><p>根据所有这些模块声明，为 com.foo.app 模块计算出的图包含以下节点和边：</p><img src="https://www.plantuml.com/plantuml/svg/PP0n3e8m58RtdgAoEC4H35TvOAreeK3147S7Bw292OERamjnC2QU1jHZ-AWbJN3w__U-_kdV-gg0l2XZGIR5aiMCfWAYX90fxQwdzhv_NSvTVIGfX6lWZ3gXZBs5b1wagKD1KTH_642k8Qg5AzY0fpAX2QebCkSOsNfPMMc8EefLyI-6EY92SXubN5FZHoS2KCoqKSm-h7tMdzkXspNlva7m5THrPxhmuFkAE6lVDy9P-xx3u8SRSMVoU8LPsWMcxU2pP8xV_GK0" alt=""><h3 id="readability" tabindex="-1"><a class="header-anchor" href="#readability"><span>Readability</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>When one module depends directly upon another in the module graph then code in the first module will be able to refer to types in the second module. We therefore say that the first module reads the second or, equivalently, that the second module is readable by the first.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>当一个模块在模块图中直接依赖另一个模块时，第一个模块中的代码将能够引用第二个模块中的类型。因此，我们说第一个模块读取第二个模块，或者换句话说，第二个模块对第一个模块是可读的。</p><p>因此，在上述图中，com.foo.app 模块读取 com.foo.bar 和 java.sql 模块，但不读取 org.baz.qux、java.xml 或 java.logging 模块。java.logging 模块可被 java.sql 模块读取，但不能被其他模块读取。（每个模块根据定义都会读取自己。）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>The readability relationships defined in a module graph are the basis of reliable configuration: The module system ensures that every dependence is fulfilled by precisely one other module, that the module graph is acyclic, that every module reads at most one module defining a given package, and that modules defining identically-named packages do not interfere with each other.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>模块图中定义的可读性关系是可靠配置的基础：模块系统确保每个依赖关系都由一个且仅一个其他模块满足，模块图是无循环的，每个模块最多读取一个定义给定包的模块，并且定义同名包的模块之间不会相互干扰。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>Reliable configuration is not just more reliable; it can also be faster. When code in a module refers to a type in a package then that package is guaranteed to be defined either in that module or in precisely one of the modules read by that module. When looking for the definition of a specific type there is, therefore, no need to search for it in multiple modules or, worse, along the entire class path.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可靠的配置不仅更加可靠，也可以更快。当模块中的代码引用一个包中的类型时，该包要么保证在该模块中被定义，要么保证仅在该模块读取的一个模块中被定义。因此，在寻找特定类型的定义时，不需要在多个模块中搜索，更不用说沿着整个类路径搜索了。</p><h3 id="accessibility" tabindex="-1"><a class="header-anchor" href="#accessibility"><span>Accessibility</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>The readability relationships defined in a module graph, combined with the exports clauses in module declarations, are the basis of strong encapsulation: The Java compiler and virtual machine consider the public types in a package in one module to be accessible by code in some other module only when the first module is readable by the second module, in the sense defined above, and the first module exports that package. That is, if two types S and T are defined in different modules, and T is public, then code in S can access T if:</span></span>
<span class="line"><span>  1. S’s module reads T’s module, and</span></span>
<span class="line"><span>  2. T’s module exports T’s package.\`\`\`</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在模块图中定义的可读性关系，结合模块声明中的导出子句，是强封装的基础：Java编译器和虚拟机仅在上述定义的意义上，一个模块可被另一个模块读取，并且第一个模块导出了该包时，才认为一个模块中的包中的公共类型可以被其他模块中的代码访问。也就是说，如果两个类型 S 和 T 定义在不同的模块中，且 T 是公共的，那么 S 中的代码可以访问 T ，如果以下条件成立：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1、S 的模块读取 T 的模块。</span></span>
<span class="line"><span>2、T 的模块导出了 T 的包。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>A type referenced across module boundaries that is not accessible in this way is unusable in the same way that a private method or field is unusable: Any attempt to use it will cause an error to be reported by the compiler, or an IllegalAccessError to be thrown by the Java virtual machine, or an IllegalAccessException to be thrown by the reflective run-time APIs. Thus, even when a type is declared public, if its package is not exported in the declaration of its module then it will only be accessible to code in that module.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>A method or field referenced across module boundaries is accessible if its enclosing type is accessible, in this sense, and if the declaration of the member itself also allows access.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>跨模块边界引用的类型如果以这种方式不可访问，那么它就像私有方法或字段不可访问一样不可用：任何尝试使用它的行为都会导致编译器报告错误，或者由Java虚拟机抛出IllegalAccessError，或者由反射运行时API抛出IllegalAccessException。因此，即使一个类型被声明为公共类型，如果它的包在其模块的声明中没有被导出，那么它只会对该模块中的代码可访问。跨模块边界引用的方法或字段是可访问的，如果其封闭类型在这种意义上是可访问的，并且如果成员本身的声明也允许访问。</p><h3 id="implied-readability" tabindex="-1"><a class="header-anchor" href="#implied-readability"><span>Implied Readability</span></a></h3><p>在某系场景下，希望实现模块A对模块B有可读性，当模块C对模块A有可读性时，希望模块C能自动对模块B有可读性。<br> 为了实现这个目标，可以使用</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">requires transitive module</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>例如下面这个例子：<br> 模块 com.foo.app 对 java.sql 可读，那么 com.foo.app 对 java.logging、java.transaction.xa和java.xml也可读。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.sql {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transitive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.logging;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transitive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.transaction.xa;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> transitive</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.xml;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> javax.sql;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uses</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql.Driver;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="compatibility-migration" tabindex="-1"><a class="header-anchor" href="#compatibility-migration"><span>Compatibility &amp; Migration</span></a></h2><p>到目前为止，我们已经了解了如何从头开始定义模块，将它们打包成模块工件，并与平台内置的模块或同样定义为工件的其他模块一起使用。当然，大多数Java代码是在引入模块系统之前编写的，必须像现在一样继续工作而无需更改。因此，模块系统尽管平台本身是由模块组成的，但仍然可以编译和运行由类路径中的JAR文件组成的应用程序。它还允许现有应用程序以灵活且逐步的方式迁移到模块化形式。</p><h3 id="the-unnamed-module" tabindex="-1"><a class="header-anchor" href="#the-unnamed-module"><span>The Unnamed Module</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>If a request is made to load a type whose package is not defined in any known module then the module system will attempt to load it from the class path. If this succeeds then the type is considered to be a member of a special module known as the unnamed module, so as to ensure that every type is associated with some module</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果请求加载一个包未在任何已知模块中定义的类型，那么模块系统将尝试从类路径加载它。如果成功，则该类型被认为是一个特殊模块（称为未命名模块）的成员，以确保每个类型都与某个模块相关联。</p><p>未命名模块读取所有其他模块。从类路径加载的任何类型中的代码都能够访问所有其他可读模块的导出类型，默认情况下包括所有命名的内置平台模块。因此，一个在 Java SE 8 上编译和运行的现有类路径应用程序，只要只使用标准的、非弃用的 Java SE API，就可以在 Java SE 9 上以完全相同的方式编译和运行。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>The unnamed module exports all of its packages. This enables flexible migration, as we shall see below. It does not, however, mean that code in a named module can access types in the unnamed module. A named module cannot, in fact, even declare a dependence upon the unnamed module.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>未命名模块会导出其所有包。这使得迁移更加灵活。然而，这并不意味着命名模块中的代码可以访问未命名模块中的类型。实际上，一个命名模块甚至不能声明对未命名模块的依赖。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>If a package is defined in both a named module and the unnamed module then the package in the unnamed module is ignored. This preserves reliable configuration even in the face of the chaos of the class path, ensuring that every module still reads at most one module defining a given package.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果一个包同时在命名模块和未命名模块中定义，那么未命名模块中的包会被忽略。这即使在类路径混乱的情况下，也能保持可靠的配置，确保每个模块最多只读取一个定义特定包的模块。</p><h3 id="bottom-up-migration" tabindex="-1"><a class="header-anchor" href="#bottom-up-migration"><span>Bottom-up migration</span></a></h3><p>将从类路径加载的类型视为未命名模块的成员，使我们能够以增量、由下而上的方式将现有应用程序的组件从 JAR 文件迁移到模块。</p><p>假设，例如，上述显示的应用程序最初是为 Java SE 8 构建的，作为一组类似命名的 JAR 文件放置在类路径上。如果我们按原样在 Java SE 9 上运行它，那么 JAR 文件中的类型将被定义在未命名模块中。该模块将读取所有其他模块，包括所有内置的平台模块；为了简单起见，假设这些模块仅限于前面显示的 java.sql、java.xml、java.logging 和 java.base 模块。因此我们得到了模块图。</p><figure><img src="`+l+'" alt="Module Graph" tabindex="0" loading="lazy"><figcaption>Module Graph</figcaption></figure><p>我们可以立即将 org-baz-qux.jar 转换为命名模块，因为我们知道它没有引用其他两个 JAR 文件中的任何类型，因此作为一个命名模块，它不会引用留在未命名模块中的任何类型。</p><p>我们为 org.baz.qux 编写一个模块声明，将其添加到模块的源代码中，进行编译，并将结果打包为一个模块化的 JAR 文件。如果我们将该 JAR 文件放置在模块路径上，而将其他文件留在类路径上，我们将获得改进的模块图。</p><figure><img src="'+t+'" alt="Module Graph" tabindex="0" loading="lazy"><figcaption>Module Graph</figcaption></figure><p>com-foo-bar.jar 和 com-foo-app.jar 中的代码继续工作，因为未命名模块读取了每个命名模块，其中现在包括新的 org.baz.qux 模块。</p><p>我们可以以类似的方式对 com-foo-bar.jar 进行模块化，然后是 com-foo-app.jar，最终形成之前展示的预期模块图：</p><figure><img src="'+r+'" alt="Module Graph" tabindex="0" loading="lazy"><figcaption>Module Graph</figcaption></figure><h3 id="automatic-modules" tabindex="-1"><a class="header-anchor" href="#automatic-modules"><span>Automatic Modules</span></a></h3><p>自底向上的迁移是直接的，但并不总是可行的。即使 org-baz-qux.jar 的维护者尚未将其转换为一个正式的模块——或者可能永远不会转换——我们仍然可能希望模块化我们的 com-foo-app.jar 和 com-foo-bar.jar 组件。</p><p>我们已经知道，com-foo-bar.jar 中的代码引用了 org-baz-qux.jar 中的类型。然而，如果我们将 com-foo-bar.jar 转换为命名模块 com.foo.bar，但将 org-baz-qux.jar 保留在类路径上，那么这些代码将无法再工作：org-baz-qux.jar 中的类型将继续定义在未命名模块中，但 com.foo.bar 是一个命名模块，不能声明对未命名模块的依赖。</p><p>我们可以将 org-baz-qux.jar 视为一个自动模块，通过将其未修改地放置在模块路径上而不是类路径上。这将定义一个可观察的模块，其名称 org.baz.qux 源自 JAR 文件的名称，以便其他非自动模块可以以通常的方式依赖于它.</p><p>自动模块是一个命名模块，它是隐式定义的，因为它没有模块声明。相比之下，普通的命名模块是通过模块声明显式定义的；我们将这些模块称为显式模块。</p><p>无法事先实际确定一个自动模块可能依赖于哪些其他模块。因此，在模块图解析完成后，自动模块会被设置为读取每个其他命名模块，无论是自动的还是显式的：</p><figure><img src="'+p+'" alt="Module Graph" tabindex="0" loading="lazy"><figcaption>Module Graph</figcaption></figure><p>同样，也没有实际的方式来判断自动模块中的哪些包是供其他模块或仍然在类路径上的类使用的。因此，自动模块中的每个包都被认为是导出的，即使它可能实际上仅供内部使用：</p><p>最后，实际上没有有效的方法来判断自动模块中的一个导出包是否包含一个类型，该类型的签名引用定义在其他自动模块中的类型。</p><p>在没有读取两个对应 JAR 文件中的所有类文件的情况下，不可能知道 com.foo.bar 中的一个公共类型是否声明了一个返回类型定义在 org.baz.qux 中的公共方法。因此，一个自动模块会隐式对所有其他自动模块授予可读性。</p><p>自动模块提供了类路径混乱与显式模块纪律之间的中间地带。它们允许现有由JAR文件组成的应用程序以自上而下的方法迁移到模块，如上所述，或者通过自上而下与自下而上的方法相结合进行迁移。我们通常可以从类路径上的任意一组JAR文件组件开始，使用像jdeps这样的工具来分析它们的相互依赖关系，将我们控制其源代码的组件转换为显式模块，并将这些组件与剩余的JAR文件按原样一起放在模块路径上。对于我们无法控制源代码的组件的JAR文件，在它们也被转换为显式模块之前，这些文件将被视为自动模块。</p><h3 id="bridges-to-the-class-path" tabindex="-1"><a class="header-anchor" href="#bridges-to-the-class-path"><span>Bridges to the class path</span></a></h3><p>许多现有的 JAR 文件可以用作自动模块，但有些不能。如果类路径上的两个或多个 JAR 文件包含同一包中的类型，那么最多只能使用其中一个作为自动模块，因为模块系统仍然保证每个命名模块最多只读取一个定义给定包的命名模块，并且定义同名包的命名模块之间不会相互干扰。在这种情况下，通常只有一个 JAR 文件是实际需要的。如果其他文件是重复或近似重复的，由于某种错误被放置在类路径上，那么可以使用其中一个作为自动模块，其他文件可以被丢弃。但是，如果类路径上的多个 JAR 文件是故意包含同一包中的类型，则它们必须保留在类路径上。</p><p>即使某些 JAR 文件不能用作自动模块，为了实现迁移，我们也允许自动模块充当显式模块中的代码与仍然在类路径上的代码之间的桥梁：除了读取每个其他命名模块之外，自动模块还被设计为读取未命名模块。如果我们的应用程序的最初类路径中，也包含了 JAR 文件 org-baz-fiz.jar 和 org-baz-fuz.jar，那么我们将拥有以下图形。</p><figure><img src="'+o+`" alt="Module Graph" tabindex="0" loading="lazy"><figcaption>Module Graph</figcaption></figure><p>一个使用类路径中的类型的自动模块不得将这些类型暴露给依赖它的显式模块，因为显式模块无法声明对未命名模块的依赖。如果显式模块 com.foo.app 中的代码引用了 com.foo.bar 中的一个公共类型，例如，该类型的签名又引用了类路径上的一个 JAR 文件中的类型，那么 com.foo.app 中的代码将无法访问该类型，因为 com.foo.app 不能依赖未命名模块。可以通过暂时将 com.foo.app 作为自动模块来解决这个问题，这样它的代码就可以访问类路径中的类型，直到类路径上的相关 JAR 文件能够被处理为自动模块或转换成显式模块。</p><p>总结一下：</p><ul><li>自动模块和未命名模块(classpath)相互之间具备可读性。</li><li>自动模块对其他命名模块和自动模块具备可读性。</li><li>自动模块自动导出所有的包。</li><li>命名模块可以手动增加对自动模块的可读性。</li></ul><h2 id="services" tabindex="-1"><a class="header-anchor" href="#services"><span>Services</span></a></h2><p>通过服务接口和服务提供者实现程序组件的松散耦合，是构建大型软件系统的强大工具。Java长期以来通过java.util.ServiceLoader类支持服务，该类通过搜索类路径在运行时定位服务提供者。对于定义在模块中的服务提供者，我们必须考虑如何在可观察模块集合中定位这些模块、解析它们的依赖关系，并将提供者提供给使用相应服务的代码。</p><p>模块系统必须能够识别先前已解析模块对服务的任何使用，然后在可观察模块集合中定位并解析服务提供者。</p><p>模块系统可以通过扫描模块工件中的类文件来识别服务的使用情况，具体是检测对 ServiceLoader::load 方法的调用，但这种方式既慢又不可靠。某个模块使用特定服务是该模块定义的一个基本方面，因此为了提高效率和清晰性，我们在模块声明中通过 uses 子句表达这一点。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> java</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.sql {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> public java.logging;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> public java.xml;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> javax.sql;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> javax.transaction.xa;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    uses</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql.Driver;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>模块系统可以通过扫描模块工件中的META-INF/services资源条目来识别服务提供者，就像ServiceLoader类如今所做的那样。然而，一个模块提供某个特定服务的实现同样是根本性的，因此我们在模块的声明中用一个provides子句来表达这一点。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">module</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> com</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">.mysql.jdbc {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    requires</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> org.slf4j;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    exports</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> com.mysql.jdbc;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    provides</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> java.sql.Driver </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">with</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> com.mysql.jdbc.Driver;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,104)]))}const m=a(h,[["render",d]]),u=JSON.parse('{"path":"/posts/java-core/jdk9/modular/TheStateOfTheModuleSystem.html","title":"The State of the Module System","lang":"en-US","frontmatter":{"title":"The State of the Module System","category":["Java"],"tag":["JDK","模块化"],"order":2,"description":"The State of the Module System 前文概述：此篇文章的内容来源于OpenJDK的一篇文档，这是我非常推荐的一种学习方式。阅读官方文档，因为在这些文档里的某些句子里面，暗藏着一些设计思路，理解思路很重要。 原文地址： The State of the Module System Goals of the module syst...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"The State of the Module System\\",\\"image\\":[\\"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms01.png\\",\\"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms02.png\\",\\"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms03.png\\",\\"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms04.png\\",\\"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms05.png\\"],\\"dateModified\\":\\"2025-07-16T15:30:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LiLiuMing\\",\\"url\\":\\"https://liliuming-truism.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://liliuming-truism.github.io/posts/java-core/jdk9/modular/TheStateOfTheModuleSystem.html"}],["meta",{"property":"og:site_name","content":"Truism-world"}],["meta",{"property":"og:title","content":"The State of the Module System"}],["meta",{"property":"og:description","content":"The State of the Module System 前文概述：此篇文章的内容来源于OpenJDK的一篇文档，这是我非常推荐的一种学习方式。阅读官方文档，因为在这些文档里的某些句子里面，暗藏着一些设计思路，理解思路很重要。 原文地址： The State of the Module System Goals of the module syst..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://liliuming-truism.github.io/assets/images/posts/java-core/tsotms01.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-07-16T15:30:03.000Z"}],["meta",{"property":"article:tag","content":"模块化"}],["meta",{"property":"article:tag","content":"JDK"}],["meta",{"property":"article:modified_time","content":"2025-07-16T15:30:03.000Z"}]]},"git":{"createdTime":1752679803000,"updatedTime":1752679803000,"contributors":[{"name":"liuming.li","username":"","email":"liumingli15@163.com","commits":1}]},"readingTime":{"minutes":19.33,"words":5800},"filePathRelative":"posts/java-core/jdk9/modular/TheStateOfTheModuleSystem.md","excerpt":"\\n<p>前文概述：此篇文章的内容来源于OpenJDK的一篇文档，这是我非常推荐的一种学习方式。阅读官方文档，因为在这些文档里的某些句子里面，暗藏着一些设计思路，理解思路很重要。<br>\\n原文地址：<br>\\n<a href=\\"https://openjdk.org/projects/jigsaw/spec/sotms/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">The State of the Module System</a></p>\\n<h2>Goals of the module system</h2>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-\\"><span class=\\"line\\"><span>Reliable configuration, to replace the brittle, error-prone class-path mechanism with a means for program components to declare explicit dependences upon one another, along with</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>Strong encapsulation, to allow a component to declare which of its public types are accessible to other components, and which are not.</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{m as comp,u as data};
